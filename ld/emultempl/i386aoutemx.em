# This shell script emits a C file. -*- C -*-
# It does some substitutions.
# Derived from generic.em and partialy from emx's ld.c
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* emulate the original gld for the given ${EMULATION_NAME}
   Copyright (C) 1991, 1993 Free Software Foundation, Inc.
   Written by Steve Chamberlain steve@cygnus.com

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "getopt.h"
#include "obstack.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldctor.h"
#include "ldgram.h"
#include "ldfile.h"
#include "ldemul.h"

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
static int gld${EMULATION_NAME}_parse_args PARAMS ((int argc, char **argv));
static bfd_boolean gld${EMULATION_NAME}_unrecognized_file PARAMS ((lang_input_statement_type *entry));


static int parse PARAMS ((char *arg, char *format, char *error));


static void
gld${EMULATION_NAME}_before_parse(void)
{
  ldfile_set_output_arch ("`echo ${ARCH}`", bfd_arch_unknown);
  output_filename = "a.out";
}

static char *
gld${EMULATION_NAME}_get_script(isfile)
     int *isfile;
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
# bird: stringify.sed is in current directory.
sc="-f stringify.sed"

#cat >>e${EMULATION_NAME}.c <<EOF
#{			
#  *isfile = 0;
#
#  if (link_info.relocatable == TRUE && config.build_constructors == TRUE)
#    return
#EOF
#sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
#echo '  ; else if (link_info.relocatable == TRUE) return' >> e${EMULATION_NAME}.c
#sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
#echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
#sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
#echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
#sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
#echo '  ; else return'                                     >> e${EMULATION_NAME}.c
#sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
#echo '; }'                                                 >> e${EMULATION_NAME}.c

cat >>e${EMULATION_NAME}.c <<EOF
{			
  *isfile = 0;

EOF
echo '  if (!config.text_read_only) return'                >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

cat >>e${EMULATION_NAME}.c <<EOF
{			
  *isfile = 1;

  if (link_info.relocatable == TRUE && config.build_constructors == TRUE)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable == TRUE)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF

fi

cat >>e${EMULATION_NAME}.c <<EOF

extern char *program_name;

/* Report a fatal error.
   FMT is a printf format string and ARG is one arg for it.  */

static void fatal VPARAMS ((char *fmt, ...))
{
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, char *, fmt);

  fprintf (stderr, "%s: ", program_name);
  vfprintf (stderr, fmt, arg);
  VA_CLOSE (arg);
  fprintf (stderr, "\n");
  xexit (1);
}

/* Parse the string ARG using scanf format FORMAT, and return the result.
   If it does not parse, report fatal error
   generating the error message using format string ERROR and ARG as arg.  */

static int
parse (arg, format, error)
  char *arg, *format, *error;
{
  int x;
  if (1 != sscanf (arg, format, &x))
    fatal (error, arg);
  return x;
}

#define OPT_ZEXE		9990
#define OPT_ZSTACK		9991
#define OPT_ZMAP		9992
#define OPT_ZNODEMANGLE		9993
#define OPT_ZDEMANGLEPROTO	9994
#define OPT_ZEMX32		9995
#define OPT_ZRSX32		9996
#define OPT_ZWIN32		9997

static struct option longopts[] =
{
  {"Zexe", 0, 0, OPT_ZEXE},	     /* Create .exe file, touch 'output file' */
  {"Zstack", 1, 0, OPT_ZSTACK},				    /* Set stack size */
  {"Zmap", 2, 0, OPT_ZMAP},				  /* Create .map file */
  {"Zno-demangle", 0, 0, OPT_ZNODEMANGLE},	    /* Don't demangle symbols */
  {"Zdemangle-proto", 0, 0, OPT_ZDEMANGLEPROTO}, /* Demangle symbols complete */
  {"Zemx32", 0, 0, OPT_ZEMX32},			 /* Create Win32/DOS emx base */
  {"Zrsx32", 0, 0, OPT_ZRSX32},		       /* Create Win32/DOS win32 base */
  {"Zwin32", 0, 0, OPT_ZWIN32},			     /* Create GUI, CUI Win32 */
  {0, 0, 0, 0}
};

#include <io.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
/* bird: clash with abort macro in ld should really include this earlier
 *       Quick fix is to undefine the abort macro.
 */
#undef abort
#include <process.h>
#define abort() ld_abort (__FILE__, __LINE__, __PRETTY_FUNCTION__)
/* bird: include headers for alloca and utime too please */
#include <alloca.h>
#include <sys/utime.h>

static const char *exe_filename;
static const char *def_filename = NULL;
static const char *res_filename = NULL;
static const char *map_filename = NULL;
static const char *touch_filename = NULL;
static int reloc_flag = 0;
static int dll_flag = 0;
static int exe_flag = 0;
static int map_flag = 0;
static int stack_size = 0;
static int emxbind_strip = 0;
enum exe_bind_type
{
  EMX_DEFAULT, RSXNT_WIN32, RSXNT_RSX, RSXNT_EMX
} rsxnt_linked = EMX_DEFAULT;

static int gld${EMULATION_NAME}_parse_args (argc, argv)
 int argc;
 char **argv;
{
  int longind;
  int optc;
  int prevoptind = optind;
  int prevopterr = opterr;

  opterr = 0;
  optc = getopt_long_only (argc, argv, "-", longopts, &longind);
  opterr = prevopterr;

  switch (optc)
  {
    default:
      optind = prevoptind;
      return 0;
    case OPT_ZEXE:
      exe_flag = 1;
      break;
    case OPT_ZSTACK:
      stack_size = parse (optarg, "%i", "invalid argument '%s' to -Zstack");
      break;
    case OPT_ZMAP:
      map_flag = 1;
      map_filename = optarg;
      break;
    case OPT_ZNODEMANGLE:
      fatal ("-Znodemangle not implemented yet");
      break;
    case OPT_ZDEMANGLEPROTO:
      fatal ("-Zdemangle-proto not implemented yet");
      break;
    case OPT_ZEMX32:
      rsxnt_linked = RSXNT_EMX;
      break;
    case OPT_ZRSX32:
      rsxnt_linked = RSXNT_RSX;
      break;
    case OPT_ZWIN32:
      rsxnt_linked = RSXNT_WIN32;
      break;
  }
  return 1;
}

/*
 * This routine is used to post-process command-line options,
 * since after_parse hook is invoked too late for us (changing
 * output_filename is not effective).
 */
static void gld${EMULATION_NAME}_set_symbols (void)
{
  char *ext, *tmp_dir, *tmp;
  size_t tmp_dir_len;

  if (rsxnt_linked != EMX_DEFAULT && link_info.strip != strip_none) /* RSXNT */
  {
    /* rsxnt can't live without all (even debugging) symbols??? */
    link_info.strip = strip_none;
    emxbind_strip = 1;
  }
  else if (link_info.strip != strip_none)
  {
    /* emxbind cant live without extern defs... */
    link_info.strip = strip_debugger;
    emxbind_strip = 1;
  }

  /* Always generate relocatable output since ld is just the first stage ... */
  link_info.relocatable = TRUE;

  if (exe_flag)
  {
    ext = _getext (output_filename);
    if ((ext != NULL) && (stricmp (ext, ".exe") == 0))
    {
      exe_filename = output_filename;
      exe_flag = 0;
    }
    else
    {
      touch_filename = strdup(output_filename);
      exe_filename = concat (output_filename, ".exe", NULL);
    }
  }
  else
  {
    ext = _getext2 (output_filename);
    if (stricmp (ext, ".dll") == 0)
    {
      link_info.relocatable = TRUE;
      dll_flag = 1;
    }
    else if (stricmp (ext, ".exe") != 0)
    {
      exe_filename = NULL;
      return;
    }
    exe_filename = output_filename;
  }

  /* Create a temporary a.out executable file. */

  tmp_dir = getenv ("TMPDIR");
  if (tmp_dir == NULL) tmp_dir = getenv ("TMP");
  if (tmp_dir == NULL) tmp_dir = getenv ("TEMP");
  if (tmp_dir == NULL) tmp_dir = ".";
  tmp_dir_len = strlen (tmp_dir);
  output_filename = tmp = xmalloc (tmp_dir_len + 10);
  memcpy (tmp, tmp_dir, tmp_dir_len);
  if (tmp_dir_len != 0 && strchr ("\\\\/:", tmp_dir[tmp_dir_len-1]) == NULL)
    tmp[tmp_dir_len++] = '\\\\';
  strcpy (tmp + tmp_dir_len, "ldXXXXXX");
  if (mktemp (tmp) == NULL)
    fatal ("mktemp(\\"%s\\") failed", output_filename);

  unlink (exe_filename);
  if (touch_filename != NULL)
    unlink (touch_filename);
}

static bfd_boolean gld${EMULATION_NAME}_unrecognized_file (entry)
 lang_input_statement_type *entry;
{
  char *ext;

  ext = _getext (entry->filename);
  if (ext != NULL)
  {
    if (stricmp (ext, ".def") == 0)
    {
      def_filename = entry->filename;
      entry->flags.loaded = TRUE;
      return TRUE;
    }
    else if (stricmp (ext, ".res") == 0)
    {
      res_filename = entry->filename;
      entry->flags.loaded = TRUE;
      return TRUE;
    }
  }

  return FALSE;
}

extern u_int _System DosCopy (char *pszSource, char *pszTarget, u_int ulOption);

/* Perform final action(s) on output file */
static void gld${EMULATION_NAME}_finish_link (char *filename)
{
  struct stat statbuf;
  int filemode, mask;

  if (stat (output_filename, &statbuf) < 0)
    fatal ("cannot query file status for %s\\n", output_filename);

  filemode = statbuf.st_mode;

  mask = umask (0);
  umask (mask);

  if (rsxnt_linked == EMX_DEFAULT && exe_filename)
  {
    char *nargv[11];
    int i, saved_errno;

    i = 0;
    nargv[i++] = "emxbind";
    nargv[i++] = "-bq";
    if (emxbind_strip)
      nargv[i++] = "-s";
    if (def_filename)
    {
      nargv[i] = alloca (strlen (def_filename) + 3);
      strcpy (nargv[i], "-d");
      strcat (nargv[i], def_filename);
      i++;
    }
    else if (dll_flag)
      nargv[i++] = "-d";

    if (stack_size != 0)
    {
      nargv[i] = alloca (20);
      sprintf (nargv[i], "-k0x%x", stack_size);
      i++;
    }

    if (map_flag)
    {
      if (map_filename == NULL)
      {
        map_filename = alloca (strlen (exe_filename) + 5);
        strcpy ((char *)map_filename, exe_filename);
        _remext ((char *)map_filename);
        strcat ((char *)map_filename, ".map");
      }
      nargv[i] = alloca (strlen (map_filename) + 3);
      strcpy (nargv[i], "-m");
      strcat (nargv[i], map_filename);
      i++;
    }

    if (res_filename)
    {
      nargv[i] = alloca (strlen (res_filename) + 3);
      strcpy (nargv[i], "-r");
      strcat (nargv[i], res_filename);
      i++;
    }

    nargv[i++] = "-o";
    nargv[i++] = (char *)exe_filename;
    nargv[i++] = (char *)output_filename;
    nargv[i] = NULL;
    i = spawnvp (P_WAIT, "emxbind", nargv);
    saved_errno = errno; unlink (output_filename); errno = saved_errno;
    if (i < 0)
      fatal ("failed to run emxbind\\n", NULL);
    else if (i != 0)
      fatal ("emxbind failed\\n", NULL);

    if (chmod (exe_filename, filemode | (0111 & ~mask)) == -1)
      fatal ("failed to write file %s\\n", exe_filename);

    if (touch_filename)
    {
      char execname[512];
      _execname(execname, sizeof(execname));
      strcpy(_getname(execname), "ldstub.bin");
      /* Copy stub into file */
      if (DosCopy(execname, (char *)touch_filename, 4))
        fatal ("cannot copy %s to %s\\n", execname, touch_filename);
      /* Now touch it */
      if (utime (touch_filename, NULL))
        fatal ("cannot touch file %s\\n", touch_filename);
    }
  }
  else if (exe_filename) /* RSXNT */
  {
    char *nargv[10];
    int i, saved_errno;

    i = 0;
    nargv[i++] = "ntbind";
    if (emxbind_strip)
      nargv[i++] = "-s";
    nargv[i++] = "-o";
    nargv[i++] = (char *)exe_filename;
    nargv[i++] = (char *)output_filename;

    if (rsxnt_linked == RSXNT_WIN32)
      nargv[i++] = (emxbind_strip) ? "dosstub.dos" : "dosstub.dbg";
    else
    {
      nargv[i++] = "dosstub.rsx";
      if (emxbind_strip)
        nargv[i++] = "-strip";
    }

    if (def_filename)
    {
      nargv[i++] = "-d";
      nargv[i] = alloca (strlen (def_filename) + 3);
      strcpy(nargv[i], def_filename);
      i++;
    }
    nargv[i] = NULL;

    i = spawnvp (P_WAIT, "ntbind", nargv);
    saved_errno = errno; unlink (output_filename); errno = saved_errno;
    if (i < 0)
      fatal ("failed to run ntbind\\n", NULL);
    else if (i != 0)
      fatal ("ntbind failed\\n", NULL);

    if (chmod (exe_filename, filemode | (0111 & ~mask)) == -1)
      fatal ("failed to write file %s\\n", exe_filename);

    if (touch_filename)
    {
      i = open (touch_filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
      if (i < 0)
        fatal ("failed to touch file %s\\n", touch_filename);
      close (i);
    }
  }
}

/* Create any output sections needed by the target.  */
static void gld${EMULATION_NAME}_create_output_section_statements (void)
{
  /* Since we enabled relocations LD marked output file as non-pageable */
  /* However, this is not TRUE for emx: always generate paged output */
  link_info.output_bfd->flags |= D_PAGED;
}

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  after_open_default,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  before_allocation_default,
  gld${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  NULL, /* finish */
  gld${EMULATION_NAME}_create_output_section_statements, /* create output section statements */
  NULL, /* open dynamic archive */
  NULL, /* place orphan */
  gld${EMULATION_NAME}_set_symbols, /* set symbols */
  gld${EMULATION_NAME}_parse_args,
  NULL, /* add_options */
  NULL, /* handle_option */
  gld${EMULATION_NAME}_unrecognized_file,
  NULL, /* list_options */
  NULL, /* recognized_file */
  NULL, /* find_potential_libraries */
  NULL,	/* new_vers_pattern.  */
  gld${EMULATION_NAME}_finish_link
};
EOF
